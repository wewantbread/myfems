<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sacred Element Cycle</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <button class="theme-toggle" type="button" aria-label="Toggle between night and day">
    <span class="theme-toggle__icon theme-toggle__icon--sun" aria-hidden="true"></span>
    <span class="theme-toggle__icon theme-toggle__icon--moon" aria-hidden="true"></span>
  </button>
  <main class="stage" aria-label="Meditative elemental aura animation">
    <div class="lightshow" aria-hidden="true">
      <span class="lightshow__beam" aria-hidden="true"></span>
      <span class="lightshow__beam" aria-hidden="true"></span>
      <span class="lightshow__beam" aria-hidden="true"></span>
      <span class="lightshow__beam" aria-hidden="true"></span>
      <span class="lightshow__beam" aria-hidden="true"></span>
      <span class="lightshow__beam" aria-hidden="true"></span>
    </div>
    <div class="figure-wrapper">
      <div
        class="figure is-chakra-active"
        role="img"
        aria-label="Chakra aligned silhouette surrounded by elemental energy"
        tabindex="0"
      >
        <img
          src="chakragirl.png"
          alt="Meditative silhouette with illuminated chakras"
          class="figure__image"
        />
        <span class="figure__outline figure__outline--primary" aria-hidden="true"></span>
        <span class="figure__outline figure__outline--secondary" aria-hidden="true"></span>
        <span class="figure__earth-aura" aria-hidden="true"></span>
        <span class="chakra chakra--third-eye" aria-hidden="true"></span>

        <div class="aura aura--leaves" aria-hidden="true">
          <span class="leaf" style="--index: 0"></span>
          <span class="leaf" style="--index: 1"></span>
          <span class="leaf" style="--index: 2"></span>
          <span class="leaf" style="--index: 3"></span>
          <span class="leaf" style="--index: 4"></span>
          <span class="leaf" style="--index: 5"></span>
          <span class="leaf" style="--index: 6"></span>
          <span class="leaf" style="--index: 7"></span>
          <span class="leaf" style="--index: 8"></span>
          <span class="leaf" style="--index: 9"></span>
          <span class="leaf" style="--index: 10"></span>
          <span class="leaf" style="--index: 11"></span>
          <span class="leaf" style="--index: 12"></span>
          <span class="leaf" style="--index: 13"></span>
          <span class="leaf" style="--index: 14"></span>
          <span class="leaf" style="--index: 15"></span>
        </div>
      </div>
      <div class="shop-tag" aria-hidden="true">
        <span class="shop-tag__label">Shop</span>
      </div>
    </div>
  </main>
  <div class="time-panel" aria-live="polite" role="status"></div>
  <script>
    const body = document.body;
    const root = document.documentElement;

    const palettes = [
      {
        light: {
          "stage-haze": "radial-gradient(circle at 50% 45%, hsla(0 0% 92% / 0.6) 0%, hsla(0 0% 78% / 0.2) 55%, transparent 80%)",
          "leaf-color": "0 0% 70%",
          "outline-color": "0 0% 82%",
          "chakra-third-eye": "0 76% 52%",
          "image-shadow": "hsla(0 0% 0% / 0.24)",
          "image-lowlight": "hsla(0 0% 0% / 0.22)",
        },
        night: {
          "stage-haze": "radial-gradient(circle at 50% 46%, hsla(0 0% 40% / 0.22) 0%, hsla(0 0% 22% / 0.12) 45%, transparent 76%)",
          "leaf-color": "0 0% 58%",
          "outline-color": "0 0% 74%",
          "chakra-third-eye": "0 74% 50%",
          "image-shadow": "hsla(0 0% 100% / 0.36)",
          "image-lowlight": "hsla(0 0% 0% / 0.6)",
        },
      },
    ];

    const applyPaletteTokens = (mode, tokens) => {
      if (!tokens) return;
      Object.entries(tokens).forEach(([token, value]) => {
        if (token === "chakra-third-eye") {
          return;
        }
        root.style.setProperty(`--palette-${mode}-${token}`, value);
      });
    };

    const applyPalette = (palette) => {
      if (!palette) return;
      applyPaletteTokens("light", palette.light);
      applyPaletteTokens("night", palette.night);
    };

    if (palettes.length) {
      const choice = palettes[Math.floor(Math.random() * palettes.length)];
      applyPalette(choice);
    }

    const figure = document.querySelector(".figure");
    const figureImage = document.querySelector(".figure__image");
    const timePanel = document.querySelector(".time-panel");
    const shopLabel = document.querySelector(".shop-tag__label");
    const lightshowBeams = Array.from(document.querySelectorAll(".lightshow__beam"));
    const ambientParticles = Array.from(
      document.querySelectorAll(".aura--leaves .leaf")
    );

    const auraBaseStops = ["#7F7979", "#755B69", "#95A78D"];
    const auraDayStops = [...auraBaseStops, "#DCD2C5", "#C2B3B5", "#D7E0D2"];
    const earthToneCandidates = [
      "#A0714C",
      "#8F6C4F",
      "#B58A5A",
      "#7B6A4D",
      "#9C8B68",
      "#C0A77B",
      "#7A5F4C",
      "#B49579",
      "#8D7657",
      "#A88461"
    ];

    const randomBetween = (min, max) => Math.random() * (max - min) + min;

    const neutralAmbientShades = ["0 0% 92%", "0 0% 76%", "0 0% 58%", "0 0% 38%"];

    const setAuraStops = (stops) => {
      const palette = stops.slice(0, 6);
      while (palette.length < 6) {
        palette.push(auraBaseStops[palette.length % auraBaseStops.length]);
      }
      palette.forEach((color, index) => {
        root.style.setProperty(`--figure-aura-stop-${index + 1}`, color);
      });
    };

    const randomEarthToneStops = () => {
      const palette = [...auraBaseStops];
      const pool = earthToneCandidates.slice();
      while (palette.length < 6) {
        const choiceIndex = Math.floor(Math.random() * pool.length);
        const [tone] = pool.splice(choiceIndex, 1);
        palette.push(tone || earthToneCandidates[Math.floor(Math.random() * earthToneCandidates.length)]);
      }
      return palette;
    };

    const applyAuraPaletteMode = (mode) => {
      if (mode === "night") {
        setAuraStops(randomEarthToneStops());
        root.style.setProperty("--figure-aura-duration", `${randomBetween(24, 34).toFixed(1)}s`);
      } else {
        setAuraStops(auraDayStops);
        root.style.setProperty("--figure-aura-duration", "32s");
      }
    };

    const storedTheme = window.localStorage.getItem("chakra-theme");
    if (storedTheme === "night" || (!storedTheme && window.matchMedia("(prefers-color-scheme: dark)").matches)) {
      body.dataset.theme = "night";
    }

    const initialMode = body.dataset.theme === "night" ? "night" : "day";
    applyAuraPaletteMode(initialMode);

    document.querySelector(".theme-toggle")?.addEventListener("click", () => {
      const isNight = body.dataset.theme === "night";
      const nextTheme = isNight ? "day" : "night";
      if (nextTheme === "night") {
        body.dataset.theme = "night";
      } else {
        delete body.dataset.theme;
      }
      window.localStorage.setItem("chakra-theme", nextTheme);
      applyAuraPaletteMode(nextTheme);
    });

    const applyAmbientTokens = () => {
      neutralAmbientShades.forEach((shade, index) => {
        root.style.setProperty(`--ambient-color-${index + 1}`, shade);
      });

      root.style.setProperty(
        "--ambient-stage-haze",
        "radial-gradient(circle at 50% 45%, hsla(0 0% 92% / 0.55) 0%, hsla(0 0% 72% / 0.2) 55%, transparent 82%)"
      );
    };

    const applyBeamStyles = () => {
      if (!lightshowBeams.length) return;
      lightshowBeams.forEach((beam) => {
        const lightness = randomBetween(52, 78).toFixed(1);
        beam.style.setProperty("--beam-hsl", `0 0% ${lightness}%`);
        beam.style.setProperty("--beam-duration", `${randomBetween(16, 24).toFixed(1)}s`);
        beam.style.setProperty("--beam-delay", `${randomBetween(-8, 8).toFixed(1)}s`);
        beam.style.setProperty("--beam-x", `${randomBetween(20, 80).toFixed(1)}%`);
        beam.style.setProperty("--beam-y", `${randomBetween(18, 82).toFixed(1)}%`);
      });
    };

    const configureAmbientParticles = () => {
      if (!ambientParticles.length) return;
      ambientParticles.forEach((particle, index) => {
        const lightness = randomBetween(46, 72).toFixed(1);
        particle.style.setProperty("--particle-hsl", `0 0% ${lightness}%`);
        const duration = randomBetween(14, 22);
        particle.style.setProperty("--particle-duration", `${duration.toFixed(1)}s`);
        particle.style.setProperty("--particle-delay", `${(index * 0.65).toFixed(1)}s`);
        const startRadius = randomBetween(6, 22);
        const endRadius = startRadius + randomBetween(4, 18);
        const angle = randomBetween(0, Math.PI * 2);
        const driftAngle = angle + randomBetween(-0.9, 0.9);
        const midAngle = (angle + driftAngle) / 2;
        const midRadius = (startRadius + endRadius) / 2;
        particle.style.setProperty("--drift-start-x", `${Math.cos(angle) * startRadius}%`);
        particle.style.setProperty("--drift-start-y", `${Math.sin(angle) * startRadius}%`);
        particle.style.setProperty("--drift-mid-x", `${Math.cos(midAngle) * midRadius}%`);
        particle.style.setProperty("--drift-mid-y", `${Math.sin(midAngle) * midRadius}%`);
        particle.style.setProperty("--drift-end-x", `${Math.cos(driftAngle) * endRadius}%`);
        particle.style.setProperty("--drift-end-y", `${Math.sin(driftAngle) * endRadius}%`);
        particle.style.setProperty("--particle-scale", randomBetween(0.72, 1.3).toFixed(2));
      });
    };

    let ambientTimer;
    const refreshAmbientScene = () => {
      applyAmbientTokens();
      applyBeamStyles();
      configureAmbientParticles();
      if (body.dataset.theme === "night") {
        applyAuraPaletteMode("night");
      }
    };

    const scheduleAmbientScene = () => {
      refreshAmbientScene();
      if (ambientTimer) {
        window.clearInterval(ambientTimer);
      }
      ambientTimer = window.setInterval(refreshAmbientScene, 16000);
    };

    const chakraSource = "chakragirl.png";

    const imageManifest = [
      {
        src: chakraSource,
        alt: "Meditative silhouette with illuminated chakras",
        label: "Chakra aligned silhouette surrounded by elemental energy",
      },
      { src: "soul1.png", alt: "Radiant soul figure one" },
      { src: "soul2.png", alt: "Radiant soul figure two" },
      { src: "soul3.png", alt: "Radiant soul figure three" },
      { src: "soul4.png", alt: "Radiant soul figure four" },
      { src: "soul5.png", alt: "Radiant soul figure five" },
      { src: "soul6.png", alt: "Radiant soul figure six" },
      { src: "goddess.png", alt: "Divine goddess figure" },
      { src: "deitys.png", alt: "Celestial deity figure" },
      { src: "gods.png", alt: "Pantheon of gods illustration" },
    ];

    const preloadImage = (entry) =>
      new Promise((resolve) => {
        const loader = new Image();
        loader.src = entry.src;
        loader.onload = () => resolve({ ...entry, available: true });
        loader.onerror = () => resolve({ ...entry, available: false });
      });

    const TRANSITION_DURATION = 2200;
    const TRANSITION_PROGRESS_RATIO = 0.45;
    const CYCLE_INTERVAL = 14000;

    let activeIndex = 0;
    let cycleTimer;
    let manifestItems = [];
    let isTransitioning = false;
    let pendingIndex = null;

    const setChakraState = (isActive) => {
      if (!figure) return;
      figure.classList.toggle("is-chakra-active", Boolean(isActive));
    };

    const updateFigureMeta = (entry) => {
      if (!figure || !figureImage) return;
      figureImage.alt = entry.alt;
      figure.setAttribute("aria-label", entry.label || entry.alt);
      figure.style.setProperty("--figure-mask", `url("${entry.src}")`);
      setChakraState(entry.src === chakraSource);
    };

    function swapImage(entry) {
      if (!figure || !figureImage) return;
      isTransitioning = true;
      figure.classList.add("is-transitioning");

      const finalize = () => {
        figure.classList.remove("is-transitioning");
        isTransitioning = false;
        if (pendingIndex !== null) {
          const queuedIndex = pendingIndex;
          pendingIndex = null;
          if (queuedIndex !== activeIndex) {
            window.requestAnimationFrame(() => advanceImage(queuedIndex));
          }
        }
      };

      const loader = new Image();
      loader.src = entry.src;
      loader.onload = () => {
        refreshAmbientScene();
        const swapDelay = TRANSITION_DURATION * TRANSITION_PROGRESS_RATIO;
        window.setTimeout(() => {
          figureImage.src = entry.src;
          updateFigureMeta(entry);
        }, swapDelay);
        window.setTimeout(finalize, TRANSITION_DURATION + 160);
      };
      loader.onerror = finalize;
    }

    function advanceImage(targetIndex) {
      if (!manifestItems.length) return;
      const nextIndex =
        typeof targetIndex === "number"
          ? (targetIndex + manifestItems.length) % manifestItems.length
          : (activeIndex + 1) % manifestItems.length;

      if (isTransitioning) {
        if (pendingIndex !== nextIndex) {
          pendingIndex = nextIndex;
        }
        return;
      }

      activeIndex = nextIndex;
      swapImage(manifestItems[nextIndex]);
    }

    const scheduleCycle = () => {
      if (cycleTimer) {
        window.clearInterval(cycleTimer);
      }
      if (manifestItems.length < 2) {
        return;
      }
      cycleTimer = window.setInterval(() => {
        advanceImage();
      }, CYCLE_INTERVAL);
    };

    const cycleImages = (manifest) => {
      manifestItems = manifest.slice();
      if (!manifestItems.length) return;

      activeIndex = 0;
      pendingIndex = null;
      isTransitioning = false;
      figureImage.src = manifestItems[0].src;
      updateFigureMeta(manifestItems[0]);

      scheduleCycle();
    };

    const handleAdvance = () => {
      if (!manifestItems.length) return;
      advanceImage();
      scheduleCycle();
    };

    const attachInteractionHandlers = () => {
      if (!figure) return;

      if ("PointerEvent" in window) {
        figure.addEventListener("pointerup", (event) => {
          if (event.pointerType === "mouse" && event.button !== 0) {
            return;
          }
          event.preventDefault();
          handleAdvance();
        });
      } else {
        let lastTouch = 0;
        figure.addEventListener("touchend", (event) => {
          lastTouch = Date.now();
          event.preventDefault();
          handleAdvance();
        });
        figure.addEventListener("click", (event) => {
          if (Date.now() - lastTouch < 400) {
            return;
          }
          handleAdvance();
        });
      }

      figure.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " " ) {
          event.preventDefault();
          handleAdvance();
        }
      });
    };

    scheduleAmbientScene();
    attachInteractionHandlers();

    Promise.all(imageManifest.map(preloadImage)).then((results) => {
      const available = results.filter((item) => item.available);
      if (!available.length) return;
      cycleImages(available);
    });

    const scrambleGlyphs = [
      "卍",
      "光",
      "心",
      "灵",
      "魂",
      "神",
      "愛",
      "氣",
      "風",
      "水",
      "火",
      "Ω",
      "Ψ",
      "Δ",
      "Σ",
      "Ж",
      "Ф",
      "Я",
      "अ",
      "आ",
      "इ",
      "ई",
      "उ",
      "ऊ",
      "ॐ",
      "ཨ",
      "ག",
      "ད",
      "ན",
      "ᚠ",
      "ᚢ",
      "ᚦ",
      "ᚨ",
      "ᛃ",
      "ሀ",
      "ለ",
      "ሐ",
      "め",
      "ら",
      "ん",
      "す",
      "星",
      "龍",
      "月",
      "陽",
      "☯",
      "✺",
      "✧",
      "✦",
      "✴",
      "✶",
      "✽",
      "❂",
      "★",
      "✵",
      "卄"
    ];

    const formatDateTime = () => {
      const now = new Date();
      return now.toLocaleString(undefined, {
        weekday: "short",
        month: "short",
        day: "2-digit",
        year: "numeric",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        hour12: false,
        timeZoneName: "short",
      });
    };

    const scrambleText = (element, finalText, duration = 4000, interval = 60) => {
      if (!element) return;
      const structure = finalText.split("").map((char) => (/^[\s,.:/-]$/.test(char) ? char : null));

      const render = () => {
        let display = "";
        for (let i = 0; i < finalText.length; i += 1) {
          const preserved = structure[i];
          if (preserved) {
            display += preserved;
          } else {
            const glyph = scrambleGlyphs[Math.floor(Math.random() * scrambleGlyphs.length)];
            display += glyph;
          }
        }
        element.textContent = display;
      };

      render();
      const timer = window.setInterval(render, interval);
      window.setTimeout(() => {
        window.clearInterval(timer);
        element.textContent = finalText;
      }, duration);
    };

    const shopTranslations = [
      "Shop",
      "Boutique",
      "Magasin",
      "Tienda",
      "Mercado",
      "Loja",
      "Negozio",
      "Butik",
      "Kauppa",
      "Sklep",
      "Winkel",
      "Obchod",
      "Butikk",
      "Sklepik",
      "Teind",
      "商店",
      "お店",
      "상점",
      "магазин",
      "दुकान",
      "مَتْجَر",
      "ร้านค้า",
      "שׁוּק",
      "Butiik",
      "市场",
      "بازار",
      "Souk",
      "Mercat",
      "Tiendita",
      "Market"
    ];

    const scrambleShopLabel = (element, duration = 4000, interval = 140) => {
      if (!element) return;
      let lastChoice = "";
      const update = () => {
        let choice = lastChoice;
        while (choice === lastChoice) {
          choice = shopTranslations[Math.floor(Math.random() * shopTranslations.length)];
        }
        lastChoice = choice;
        element.textContent = choice;
      };

      update();
      const timer = window.setInterval(update, interval);
      window.setTimeout(() => {
        window.clearInterval(timer);
        element.textContent = "Shop";
      }, duration);
    };

    const updateClock = () => {
      if (!timePanel) return;
      timePanel.textContent = formatDateTime();
    };

    const initializeClock = () => {
      if (!timePanel) return;
      const initial = formatDateTime();
      scrambleText(timePanel, initial, 4000);
      window.setTimeout(() => {
        updateClock();
        window.setInterval(updateClock, 1000);
      }, 4000);
    };

    scrambleShopLabel(shopLabel);
    initializeClock();
  </script>
</body>
</html>
